了解！Python から FFmpeg を使うなら、用途別に次の2択が鉄板です。結論だけ先に：
	•	本番・再現性重視（サーバ／WSL2／CI） → Dockerで OS パッケージの FFmpeg を入れる（推奨）
	•	手早くクロスプラットフォームに動かしたい → requirements.txt に imageio-ffmpeg を入れる（FFmpeg 本体同梱）  ￼ ￼

⸻

1) Dockerで入れる（最も再現性が高い）

Debian/Ubuntu 系（軽量・無難）

# ベースは好みでpython:3.x-slim等
FROM python:3.11-slim

# ffmpeg を OS パッケージで導入（ffprobe も同梱）
RUN apt-get update \
 && apt-get install -y --no-install-recommends ffmpeg \
 && rm -rf /var/lib/apt/lists/*

# Python ライブラリ（必要に応じて）
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

WORKDIR /app
COPY . .
CMD ["python", "main.py"]

apt-get install ffmpeg で CLI の ffmpeg と ffprobe が入り、PATH が通ります。  ￼

Alpine 系（さらに軽量）

FROM python:3.11-alpine
RUN apk add --no-cache ffmpeg
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
WORKDIR /app
COPY . .
CMD ["python", "main.py"]

もし 特定の新しめの FFmpeg 機能（例: v6+ のフィルタ）を確実に使いたい場合、ディストリの標準版が古いことがあります。その場合は Docker 内で静的ビルドを取得 するか、外部リポジトリ／自前ビルドに切り替える運用も検討してください。  ￼

⸻

2) requirements.txt だけで完結させる（FFmpeg 同梱）

imageio-ffmpeg は プラットフォーム別ホイールに FFmpeg 実行ファイルを同梱しています（約60MB）。Python 側から get_ffmpeg_exe() で実体パスが取れるので、そのまま subprocess や他ライブラリから使えます。
requirements.txt 例：

imageio-ffmpeg>=0.4
ffmpeg-python>=0.2   # （任意）流れるようなAPIでコマンドを組み立てたい場合

	•	imageio-ffmpeg：FFmpeg バイナリを提供し、IMAGEIO_FFMPEG_EXE 環境変数や同梱・conda・システムの順で検出します。  ￼ ￼ ￼
	•	ffmpeg-python：CLI のラッパー（FFmpeg 本体は別途必要）。上の imageio-ffmpeg と併用すると楽です。  ￼ ￼
	•	（代替）PyAV：FFmpeg ライブラリに直接バインディング。最近は FFmpeg にリンク済みのバイナリホイールが配布されます（機能豊富な代わりにサイズ大きめ/ビルド相性に注意）。  ￼

⸻

3) 具体的な使い方サンプル

A. imageio-ffmpeg + subprocess（一番シンプル）

from pathlib import Path
import subprocess
import imageio_ffmpeg as iio

ffmpeg = iio.get_ffmpeg_exe()  # 同梱 or 環境変数 or システムから自動検出
inp = Path("input.avi")
out = Path("output.mp4")

cmd = [
    ffmpeg, "-y", "-hide_banner", "-loglevel", "error",
    "-i", str(inp),
    "-c:v", "libx264", "-crf", "23", "-preset", "veryfast",
    "-c:a", "aac", "-b:a", "192k",
    str(out),
]
subprocess.run(cmd, check=True)

IMAGEIO_FFMPEG_EXE を設定すれば使用する FFmpeg を固定できます。  ￼

B. ffmpeg-python（Python っぽくフィルタを組み立て）

import ffmpeg
import imageio_ffmpeg as iio
import os

# ffmpeg-python は既定で "ffmpeg" を呼ぶので、PATHを通すか以下のように上書き
os.environ["PATH"] = f"{os.pathsep}{os.path.dirname(iio.get_ffmpeg_exe())}{os.pathsep}{os.environ.get('PATH','')}"

(
    ffmpeg
    .input("input.avi")
    .output("output.mp4", vcodec="libx264", crf=23, preset="veryfast", acodec="aac", audio_bitrate="192k")
    .overwrite_output()
    .run(quiet=True)
)

ffmpeg-python 自体は FFmpeg 本体を同梱しないため、上のように PATH にバイナリを見せるのが楽です。  ￼

C. PyAV（ライブラリ直叩き）

# requirements.txt に
av>=11

import av
with av.open("input.mp4") as container:
    for frame in container.decode(video=0):
        img = frame.to_image()
        # 画像処理...

PyPI の av は FFmpeg にリンク済みのホイールが提供されています（環境によりサイズ大きめ）。  ￼

⸻

4) どっちが最適？
	•	長期運用・誰の環境でも同じ結果にしたい → Docker
	•	OS パッケージで ffmpeg/ffprobe が確実に入り、PATH も統一。CI/CD で再現性◎。  ￼
	•	配布が pip 中心／なるべくセットアップを簡単に → imageio-ffmpeg
	•	プロジェクトだけで完結しやすい（FFmpeg 同梱）。サイズは ~60MB 増えるが扱いが楽。  ￼
	•	細かいフレーム操作や低レベル制御 → PyAV も候補。  ￼

⸻

5) ハマりどころ（回避策）
	•	pip の ffmpeg という別パッケージは本体ではなく別物です。本体は OS/同梱で用意し、Python 側はラッパーを使う、が基本。 ￼
	•	H.264 などのコーデック可否はパッケージ源に依存（Anaconda の defaults ffmpeg では H.264 非対応など）。必要なら conda-forge 版や OS パッケージ、静的ビルドを
 Dockerfile や 社内リポジトリ向け requirements.txt を作って渡します。どちらで進めるかだけ教えてくれれば、その前提で即仕上げます！


---



了解！requirements.txt で必要ライブラリを入れて、Python から AVI → MP4 (H.264 + AAC) に変換する最小セットを用意しました。
※ ffmpeg の“本体”は OS に入っていないと動かないことが多いですが、ここでは imageio-ffmpeg が同梱する ffmpeg 実行ファイル を使うので、追加インストールなしで動きます 👍

1) requirements.txt

ffmpeg-python>=0.2.0
imageio-ffmpeg>=0.4.9
tqdm>=4.66

2) 変換スクリプト（単発/一括どちらも対応）

convert_avi_to_mp4.py

import argparse
import pathlib
from tqdm import tqdm
import ffmpeg
import imageio_ffmpeg

FFMPEG_EXE = imageio_ffmpeg.get_ffmpeg_exe()

def convert_one(in_path: pathlib.Path, out_path: pathlib.Path, crf: int, preset: str, nvenc: bool, overwrite: bool):
    vcodec = "h264_nvenc" if nvenc else "libx264"  # NVIDIA GPUがあれば --nvenc で高速化
    stream = (
        ffmpeg
        .input(str(in_path))
        .output(
            str(out_path),
            vcodec=vcodec,
            pix_fmt="yuv420p",    # ブラウザ再生互換
            crf=crf,              # 品質(数値↓=高品質/大容量) 目安: 18-28
            preset=preset,        # エンコード速度(速いほど画質コスパ低下)
            acodec="aac",
            audio_bitrate="192k",
            movflags="+faststart" # Web配信向け
        )
    )

    try:
        ffmpeg.run(
            stream,
            cmd=FFMPEG_EXE,
            overwrite_output=overwrite,
            capture_stdout=True,
            capture_stderr=True
        )
    except ffmpeg.Error as e:
        raise RuntimeError(e.stderr.decode("utf-8", errors="ignore"))

def main():
    p = argparse.ArgumentParser(description="Convert AVI to MP4 (H.264 + AAC)")
    p.add_argument("src", help="入力: AVIファイル または ディレクトリ")
    p.add_argument("-o", "--out", help="出力ファイル/ディレクトリ（省略時は同階層に .mp4 を生成）")
    p.add_argument("--crf", type=int, default=23, help="画質CRF(18-28推奨, 小さいほど高品質/大容量)")
    p.add_argument("--preset", default="medium", help="x264/nvenc preset (ultrafast..placebo / default=medium)")
    p.add_argument("--nvenc", action="store_true", help="NVIDIA GPUでエンコード(h264_nvenc)を使用")
    p.add_argument("--overwrite", action="store_true", help="既存の出力を上書き")
    p.add_argument("--recursive", action="store_true", help="ディレクトリ入力時に再帰探索")
    args = p.parse_args()

    src_path = pathlib.Path(args.src)
    if not src_path.exists():
        raise FileNotFoundError(f"入力が見つかりません: {src_path}")

    # 単発ファイル
    if src_path.is_file():
        if args.out:
            out_path = pathlib.Path(args.out)
            if out_path.is_dir():
                out_path = out_path / (src_path.stem + ".mp4")
        else:
            out_path = src_path.with_suffix(".mp4")

        convert_one(src_path, out_path, args.crf, args.preset, args.nvenc, args.overwrite)
        print(f"OK: {src_path.name} -> {out_path}")

    # ディレクトリ一括
    else:
        if args.recursive:
            avi_list = list(src_path.rglob("*.avi"))
        else:
            avi_list = list(src_path.glob("*.avi"))

        if not avi_list:
            print("AVIファイルが見つかりませんでした。")
            return

        if args.out:
            out_dir = pathlib.Path(args.out)
            out_dir.mkdir(parents=True, exist_ok=True)
        else:
            out_dir = None

        for in_f in tqdm(avi_list, desc="Converting"):
            if out_dir:
                rel = in_f.relative_to(src_path) if args.recursive else in_f.name
                rel_path = rel if isinstance(rel, pathlib.Path) else pathlib.Path(rel)
                out_path = (out_dir / rel_path).with_suffix(".mp4")
                out_path.parent.mkdir(parents=True, exist_ok=True)
            else:
                out_path = in_f.with_suffix(".mp4")

            if out_path.exists() and not args.overwrite:
                # スキップ
                continue

            try:
                convert_one(in_f, out_path, args.crf, args.preset, args.nvenc, args.overwrite)
            except Exception as e:
                print(f"NG: {in_f} -> {e}")

        print("完了")

if __name__ == "__main__":
    main()

3) 使い方

# 仮想環境は任意
python -m venv .venv
./.venv/Scripts/activate  # Windows
# source .venv/bin/activate  # macOS/Linux

pip install -r requirements.txt

# 単発変換
python convert_avi_to_mp4.py path/to/input.avi

# 出力先を指定
python convert_avi_to_mp4.py path/to/input.avi -o path/to/output.mp4

# ディレクトリ内の .avi を一括変換（同じ階層に .mp4 を作成）
python convert_avi_to_mp4.py path/to/dir

# 出力先ディレクトリをまとめたい場合
python convert_avi_to_mp4.py path/to/dir -o out_dir

# 再帰的にサブフォルダも処理
python convert_avi_to_mp4.py path/to/dir --recursive

# 品質/速度の調整（例: 高品質/やや遅い）
python convert_avi_to_mp4.py input.avi --crf 20 --preset slow

# 既存ファイルを上書き
python convert_avi_to_mp4.py input.avi --overwrite

# NVIDIA GPU で高速エンコード（対応環境のみ）
python convert_avi_to_mp4.py input.avi --nvenc

パラメータの目安
	•	--crf: 18（高品質・大きい）～ 28（低品質・小さい）。デフォルト 23。まずは 20–24 で調整。
	•	--preset: faster にするほどエンコードは速くなるが圧縮効率は落ちる。medium で困らなければそのまま。
	•	--nvenc: 対応 GPU があればかなり速くなります（ファイルサイズはやや大きくなりがち）。

補足
	•	ブラウザ/HTML5 <video> での再生互換のため、H.264 + AAC / yuv420p にしています。
	•	変換に失敗する AVI（壊れかけ・古いコーデック）に遭遇したら、まず単発で実行して標準エラーの内容を見てください。必要に応じて -an（音声なし）や -sn（字幕なし）を ffmpeg_params に追加する手もあります。

必要なら Docker 版（イメージに ffmpeg を同梱）も出せますが、まずはこの requirements.txt 方式でサクッと回るはず。欲しい拡張（ロスレス、解像度変更、フレームレート変更、音声のみ抽出など）があれば言ってください。


