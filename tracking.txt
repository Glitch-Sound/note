ã‚‚ã¡ã‚ã‚“ã§ã™ã€‚
ã€Œtracking-by-detectionï¼ˆãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ãƒ»ãƒã‚¤ãƒ»ãƒ‡ã‚£ãƒ†ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ã€ã¯ã€
ã€Œç‰©ä½“ã‚’æ¤œå‡ºã—ã¦ã‹ã‚‰è¿½è·¡ã™ã‚‹ã€ã¨ã„ã†ã€ã¨ã¦ã‚‚åˆ†ã‹ã‚Šã‚„ã™ã„è€ƒãˆæ–¹ã®æ‰‹æ³•ã§ã™ã€‚
åˆå¿ƒè€…ã‚„éã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã®æ–¹ã«ã‚‚ç†è§£ã—ã‚„ã™ã„ã‚ˆã†ã«ã€ä¾‹ã‚’äº¤ãˆã¦èª¬æ˜ã—ã¾ã™ã­ã€‚

â¸»

ğŸ§© tracking-by-detection ã¨ã¯ï¼Ÿ

åå‰ã®é€šã‚Šã€

ã€Œæ¤œå‡ºï¼ˆdetectionï¼‰ã—ãŸçµæœã‚’ä½¿ã£ã¦ã€åŒã˜ç‰©ä½“ã‚’è¿½ã„ã‹ã‘ã‚‹ï¼ˆtrackingï¼‰ã€
ã¨ã„ã†æµã‚Œã®ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°æ–¹æ³•ã§ã™ã€‚

ã¤ã¾ã‚Šã€1ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã« YOLO ã®ã‚ˆã†ãªã€Œç‰©ä½“æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ã€ã§äººã‚„è»Šãªã©ã‚’è¦‹ã¤ã‘ã¦ã€
ã€Œã“ã‚Œã¯ã•ã£ãã®è»Šã¨åŒã˜ã ã€ã¨åˆ¤æ–­ã—ã¦ ID ã‚’ã¤ã‘ã¦è¿½ã„ã‹ã‘ã‚‹ ä»•çµ„ã¿ã§ã™ã€‚

â¸»

ğŸ¬ ã©ã†ã‚„ã£ã¦å‹•ãã®ã‹ï¼Ÿ

â‘  å„ãƒ•ãƒ¬ãƒ¼ãƒ ã§ç‰©ä½“ã‚’æ¤œå‡ºã™ã‚‹

ä¾‹ï¼šãƒ‰ãƒ©ãƒ¬ã‚³æ˜ åƒã®1ãƒ•ãƒ¬ãƒ¼ãƒ ç›®ã§ YOLO ãŒ
	â€¢	è»ŠAï¼ˆåº§æ¨™x1,y1,w,hï¼‰
	â€¢	è»ŠBï¼ˆåº§æ¨™x2,y2,w,hï¼‰
ã‚’è¦‹ã¤ã‘ã¾ã™ã€‚

ã“ã‚Œã‚’ã€Œæ¤œå‡ºï¼ˆdetectionï¼‰ã€ã¨å‘¼ã³ã¾ã™ã€‚

â¸»

â‘¡ 1ãƒ•ãƒ¬ãƒ¼ãƒ å‰ã¨ã®å¯¾å¿œã‚’å–ã‚‹

æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚‚ã¾ãŸ YOLO ãŒæ¤œå‡ºã—ã¾ã™ã€‚
ã™ã‚‹ã¨åŒã˜ã‚ˆã†ãªä½ç½®ã«è»ŠãŒã„ã¾ã™ã€‚

ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã“ã†è€ƒãˆã¾ã™ğŸ‘‡

ã€Œå‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®è»ŠAã¨ä»Šã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã“ã®è»Šã¯è¿‘ã„å ´æ‰€ã«ã„ã‚‹ã‹ã‚‰ã€åŒã˜è»Šã ã‚ã†ï¼ã€

ã“ã†ã—ã¦ã€ã€ŒAã€ã€ŒBã€ã¨ã„ã£ãŸ ID ã‚’ã¤ã‘ã¦è¿½ã„ã‹ã‘ã¾ã™ã€‚
ã“ã‚Œã‚’ã€Œãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼ˆtrackingï¼‰ã€ã¨å‘¼ã³ã¾ã™ã€‚

â¸»

â‘¢ æ¤œå‡ºãŒæ¶ˆãˆãŸæ™‚ã‚‚è£œã†

æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ãŒä¸€ç¬å¤±æ•—ã™ã‚‹ï¼ˆä¾‹ãˆã°å½±ã§éš ã‚Œã‚‹ï¼‰ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚
ãã®å ´åˆã‚‚ã€Œå‰å›ã®å‹•ãã®æ–¹å‘ã€ã‚’ã‚‚ã¨ã«ã€
ã€Œã“ã®ã‚ãŸã‚Šã«ã¾ã ã„ã‚‹ã¯ãšã€ã¨äºˆæ¸¬ã—ã¦è¿½è·¡ã‚’ç¶šã‘ã¾ã™ã€‚
ã“ã®äºˆæ¸¬ã«ã¯ã€Œã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã€ã¨ã„ã†è¨ˆç®—æ‰‹æ³•ãŒã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚

â¸»

â‘£ IDã‚’ç¶­æŒã—ãªãŒã‚‰è¨˜éŒ²ã™ã‚‹

ã“ã†ã—ã¦å„ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã€Œæ¤œå‡ºçµæœã€ã‚’ã¤ãªãåˆã‚ã›ã€
åŒã˜ç‰©ä½“ã«åŒã˜ ID ã‚’ã¤ã‘ç¶šã‘ã‚‹ã“ã¨ã§ã€
ã€Œ1å°ã®è»ŠãŒæ˜ åƒã®ä¸­ã§ã©ã®ã‚ˆã†ã«å‹•ã„ãŸã‹ã€ã‚’è¿½ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

â¸»

âš™ï¸ ç‰¹å¾´

é …ç›®	å†…å®¹
ğŸ’¡ æ§‹æˆ	ã€Œæ¤œå‡ºï¼ˆYOLOãªã©ï¼‰ã€ï¼‹ã€Œè¿½è·¡ï¼ˆSORTãªã©ï¼‰ã€ã®çµ„ã¿åˆã‚ã›
ğŸ” æ¤œå‡ºå™¨	YOLOãƒ»Detectronãƒ»RT-DETR ãªã© ã©ã‚Œã§ã‚‚å·®ã—æ›¿ãˆå¯
ğŸ“¦ å‡ºåŠ›	å„ãƒ•ãƒ¬ãƒ¼ãƒ ã®ç‰©ä½“ã« ID ãŒå‰²ã‚ŠæŒ¯ã‚‰ã‚ŒãŸçŠ¶æ…‹ï¼ˆä¾‹ï¼šcar_1, car_2ï¼‰
ğŸ’ª ãƒ¡ãƒªãƒƒãƒˆ	ãƒ¢ãƒ‡ãƒ«ã«ä¾å­˜ã›ãšæŸ”è»Ÿã€‚ç²¾åº¦ã®é«˜ã„æ¤œå‡ºå™¨ã‚’ä½¿ã†ã»ã©è¿½è·¡ã‚‚å®‰å®š
âš ï¸ ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ	æ¤œå‡ºãŒé€”åˆ‡ã‚Œã‚‹ã¨ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã‚‚æ­¢ã¾ã‚Šã‚„ã™ã„ï¼ˆè£œåŠ©ãŒå¿…è¦ï¼‰


â¸»

ğŸ‘€ ã‚ˆãä½¿ã‚ã‚Œã‚‹ä»£è¡¨çš„ãªãƒˆãƒ©ãƒƒã‚«ãƒ¼

ã“ã‚Œã‚‰ã¯ã€Œtracking-by-detectionã€ã‚’å®Ÿç¾ã™ã‚‹ä»£è¡¨çš„ãªå®Ÿè£…ã§ã™ã€‚

ãƒˆãƒ©ãƒƒã‚«ãƒ¼å	ç‰¹å¾´
SORT	æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã€‚ä½ç½®æƒ…å ±ã ã‘ã§è¿½è·¡ã€‚é«˜é€Ÿã€‚
DeepSORT	ä½ç½®ï¼‹è¦‹ãŸç›®ã®ç‰¹å¾´ã§ã‚ˆã‚Šå®‰å®šã€‚
ByteTrack	å¼±ã„æ¤œå‡ºï¼ˆã‚¹ã‚³ã‚¢ä½ã„ï¼‰ã‚‚ä¸Šæ‰‹ã«æ´»ç”¨ã—ã¦IDç¶­æŒã€‚ç²¾åº¦é«˜ã‚ã€‚
OC-SORT	ã‚ªãƒ—ãƒ†ã‚£ã‚«ãƒ«ãƒ•ãƒ­ãƒ¼ãªã©å‹•ãæƒ…å ±ã‚‚å–ã‚Šå…¥ã‚Œã¦æ»‘ã‚‰ã‹ã«è¿½è·¡ã€‚

ã©ã‚Œã‚‚ æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ã«ä¾å­˜ã—ãªã„æ±ç”¨è¨­è¨ˆ ã§ã™ã€‚

â¸»

ğŸš— ãƒ‰ãƒ©ãƒ¬ã‚³ã®ä¾‹ã§è¨€ã†ã¨

ã‚¹ãƒ†ãƒƒãƒ—	å†…å®¹
â‘ 	å„ãƒ•ãƒ¬ãƒ¼ãƒ ã§ YOLO ãŒã€Œè»Šã€ã€Œæ­©è¡Œè€…ã€ã€Œä¿¡å·ã€ãªã©ã‚’æ¤œå‡º
â‘¡	ãƒˆãƒ©ãƒƒã‚«ãƒ¼ãŒã€Œå‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ä½ç½®ãŒè¿‘ã„ã‚‚ã®ã€ã‚’åŒä¸€IDã¨åˆ¤æ–­
â‘¢	åŒã˜è»Šã«ã¯ãšã£ã¨ ID=5 ãªã©ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹
â‘£	æ¤œå‡ºçµæœã‚’ç·šã§ã¤ãªã’ã°ã€è»Šã®èµ°è¡Œè»Œè·¡ãŒå–ã‚Œã‚‹

â†’ åŒä¸€ã®ç‰©ä½“ã‚’â€œã²ã¨ã¤ã«ã¾ã¨ã‚ã‚‹â€ã“ã¨ãŒå¯èƒ½ã€‚

â¸»

ğŸ§  ã¾ã¨ã‚
	â€¢	ã€Œtracking-by-detectionã€ã¯
ã€€æ¤œå‡ºçµæœã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸâ€œç‰©ä½“ã®è¿½è·¡â€æ‰‹æ³•ã€‚
	â€¢	æ¤œå‡ºãƒ¢ãƒ‡ãƒ«ï¼ˆYOLOãªã©ï¼‰ã«ä¾å­˜ã—ãªã„ã€‚
	â€¢	ä½ç½®ã¨æ™‚é–“ã®ã¤ãªãŒã‚Šã‹ã‚‰åŒã˜ç‰©ä½“ã‚’è¿½ã„ã‹ã‘ã‚‹ã€‚
	â€¢	é–‹ç™ºãŒæ¯”è¼ƒçš„ã‚·ãƒ³ãƒ—ãƒ«ã§ã€å†åˆ©ç”¨æ€§ãŒé«˜ã„ã€‚
	â€¢	ãƒ‰ãƒ©ãƒ¬ã‚³ã®ã‚ˆã†ãªã‚·ãƒ¼ãƒ³ã§ã‚‚å®Ÿç”¨çš„ã€‚

â¸»

ã”å¸Œæœ›ãŒã‚ã‚Œã°æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦ã€
ã€Œã©ã‚“ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§IDã‚’ç®¡ç†ã™ã‚‹ã‹ã€ã€ŒYOLOä»¥å¤–ã«ã‚‚å¯¾å¿œã§ãã‚‹ä»•çµ„ã¿è¨­è¨ˆã€ã‚’
å›³ä»˜ãï¼ˆMermaidï¼‰ã§èª¬æ˜ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ç¶šã‘ã¦è¦‹ãŸã„ã§ã™ã‹ï¼Ÿ


------


äº†è§£ã€‚æ¤œå‡ºå™¨éä¾å­˜ï¼ˆYOLOä»¥å¤–ã§ã‚‚OKï¼‰ã®æœ€å°å®Ÿè£…ã‚µãƒ³ãƒ—ãƒ«ã‚’ç½®ãã¾ã™ã€‚
å…¥åŠ›ã¯å„ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ¤œå‡ºçµæœï¼ˆ[x1,y1,x2,y2,score,class_id]ã®é…åˆ—ï¼‰ã€‚å‡ºåŠ›ã¯ä¸€è²«ã—ãŸtrack_idä»˜ãã®ãƒœãƒƒã‚¯ã‚¹ã§ã™ã€‚

tracker.py

# -*- coding: utf-8 -*-
"""
Generic Tracking-by-Detection (detector-agnostic)
- Greedy IoU matching + ç°¡æ˜“ãªé€Ÿåº¦æ¨å®šï¼ˆå‰ãƒ•ãƒ¬ãƒ¼ãƒ â†’æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã®Î”ã‹ã‚‰ï¼‰
- æ¬ æ¸¬è€æ€§ï¼ˆmax_ageï¼‰/ç¢ºä¿¡åŒ–ï¼ˆmin_hitsï¼‰
- ä»»æ„ã§ã‚ªãƒ—ãƒ†ã‚£ã‚«ãƒ«ãƒ•ãƒ­ãƒ¼è£œåŠ©ï¼ˆcv2.calcOpticalFlowFarnebackï¼‰ã‚’ONã«ã§ãã‚‹
  â€» ãƒ•ãƒ­ãƒ¼ã¯èƒŒæ™¯ã®å¤§åŸŸç§»å‹•ã‚’æ¦‚ç®—è£œæ­£ã™ã‚‹ç”¨é€”ï¼ˆå³å¯†ãªã‚¨ã‚´ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ¨å®šã§ã¯ãªã„ï¼‰
ä¾å­˜: numpy, (ä»»æ„) opencv-python
"""

from dataclasses import dataclass
from typing import List, Tuple, Optional
import numpy as np

try:
    import cv2
    _HAS_CV2 = True
except Exception:
    _HAS_CV2 = False


# ---------------------------
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
# ---------------------------

def iou_xyxy(a: np.ndarray, b: np.ndarray) -> float:
    """a,b: [x1,y1,x2,y2]"""
    x1 = max(a[0], b[0]); y1 = max(a[1], b[1])
    x2 = min(a[2], b[2]); y2 = min(a[3], b[3])
    inter = max(0.0, x2 - x1) * max(0.0, y2 - y1)
    if inter == 0: return 0.0
    area_a = (a[2]-a[0])*(a[3]-a[1])
    area_b = (b[2]-b[0])*(b[3]-b[1])
    return inter / (area_a + area_b - inter + 1e-6)

def xywh_to_xyxy(xywh: np.ndarray) -> np.ndarray:
    x,y,w,h = xywh
    return np.array([x, y, x+w, y+h], dtype=float)

def xyxy_to_xywh(xyxy: np.ndarray) -> np.ndarray:
    x1,y1,x2,y2 = xyxy
    return np.array([x1, y1, x2-x1, y2-y1], dtype=float)


# ---------------------------
# ãƒˆãƒ©ãƒƒã‚¯å®šç¾©
# ---------------------------

@dataclass
class Track:
    track_id: int
    bbox_xyxy: np.ndarray  # [x1,y1,x2,y2]
    cls: int
    score: float
    vx: float = 0.0
    vy: float = 0.0
    age: int = 0              # ç”Ÿæˆã‹ã‚‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
    time_since_update: int = 0
    hits: int = 0             # ãƒãƒƒãƒå›æ•°ï¼ˆç¢ºä¿¡åŒ–ã«ä½¿ã†ï¼‰

    def predict(self):
        """å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®é€Ÿåº¦ã§ä½ç½®ã‚’äºˆæ¸¬ï¼ˆç°¡æ˜“CVãƒ¢ãƒ‡ãƒ«ï¼‰"""
        dx, dy = self.vx, self.vy
        self.bbox_xyxy = self.bbox_xyxy + np.array([dx, dy, dx, dy], dtype=float)
        self.age += 1
        self.time_since_update += 1

    def update(self, det_bbox_xyxy: np.ndarray, score: float):
        """æ¤œå‡ºã¨ãƒãƒƒãƒã—ãŸã‚‰ä½ç½®ï¼†é€Ÿåº¦æ›´æ–°"""
        cx_prev = (self.bbox_xyxy[0] + self.bbox_xyxy[2]) * 0.5
        cy_prev = (self.bbox_xyxy[1] + self.bbox_xyxy[3]) * 0.5
        cx_new = (det_bbox_xyxy[0] + det_bbox_xyxy[2]) * 0.5
        cy_new = (det_bbox_xyxy[1] + det_bbox_xyxy[3]) * 0.5

        self.vx = cx_new - cx_prev
        self.vy = cy_new - cy_prev
        self.bbox_xyxy = det_bbox_xyxy.astype(float)
        self.score = score
        self.time_since_update = 0
        self.hits += 1


# ---------------------------
# ãƒ¡ã‚¤ãƒ³ãƒˆãƒ©ãƒƒã‚«ãƒ¼
# ---------------------------

class SimpleTracker:
    def __init__(
        self,
        iou_threshold: float = 0.3,
        max_age: int = 15,
        min_hits: int = 3,
        use_optical_flow: bool = False,
        flow_downscale: int = 2
    ):
        """
        iou_threshold : ãƒãƒƒãƒè¨±å®¹IoUä¸‹é™
        max_age       : æ›´æ–°ãŒé€”åˆ‡ã‚Œã¦ã‚‚ä¿æŒã™ã‚‹æœ€å¤§ãƒ•ãƒ¬ãƒ¼ãƒ æ•°
        min_hits      : ã“ã‚Œã‚’è¶…ãˆãŸã‚‰ã€Œç¢ºä¿¡ã—ãŸãƒˆãƒ©ãƒƒã‚¯ã€ã¨ã—ã¦å‡ºåŠ›
        use_optical_flow : Trueã§ãƒ•ãƒ­ãƒ¼è£œåŠ©ï¼ˆcv2å¿…è¦ï¼‰
        flow_downscale: ãƒ•ãƒ­ãƒ¼è¨ˆç®—æ™‚ã®ç¸®å°ç‡ï¼ˆ2ã§1/2è§£åƒåº¦ï¼‰
        """
        self.iou_threshold = iou_threshold
        self.max_age = max_age
        self.min_hits = min_hits
        self.use_optical_flow = use_optical_flow and _HAS_CV2
        self.flow_downscale = flow_downscale
        self.tracks: List[Track] = []
        self._next_id = 1
        self._prev_gray: Optional[np.ndarray] = None
        self._prev_frame_small: Optional[np.ndarray] = None
        self._flow: Optional[np.ndarray] = None

    def _compute_flow(self, frame_bgr: np.ndarray):
        if not self.use_optical_flow:
            self._flow = None
            return
        if not _HAS_CV2:
            self._flow = None
            return

        # å‰å‡¦ç†ï¼ˆç¸®å°ï¼†ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
        h, w = frame_bgr.shape[:2]
        small = cv2.resize(frame_bgr, (w//self.flow_downscale, h//self.flow_downscale))
        gray = cv2.cvtColor(small, cv2.COLOR_BGR2GRAY)

        if self._prev_gray is None:
            self._prev_gray = gray
            self._prev_frame_small = small
            self._flow = None
            return

        # Farnebackãƒ•ãƒ­ãƒ¼
        flow = cv2.calcOpticalFlowFarneback(
            self._prev_gray, gray, None,
            pyr_scale=0.5, levels=3, winsize=15, iterations=3,
            poly_n=5, poly_sigma=1.2, flags=0
        )
        self._flow = flow  # (H',W',2) å³(+x),ä¸‹(+y)æ–¹å‘ã®ãƒ”ã‚¯ã‚»ãƒ«ç§»å‹•
        self._prev_gray = gray
        self._prev_frame_small = small

    def _flow_shift(self, box_xyxy: np.ndarray) -> Tuple[float, float]:
        """ãƒœãƒƒã‚¯ã‚¹å†…ã®å¹³å‡ãƒ•ãƒ­ãƒ¼ã§èƒŒæ™¯ç§»å‹•ã‚’æ¦‚ç®—ï¼ˆãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯èƒŒæ™¯è£œæ­£ã®ç°¡æ˜“ç‰ˆï¼‰"""
        if self._flow is None:
            return 0.0, 0.0

        x1, y1, x2, y2 = box_xyxy.astype(int)
        if x2 <= x1 or y2 <= y1:
            return 0.0, 0.0

        # ãƒ•ãƒ­ãƒ¼ã¯ç¸®å°ç©ºé–“ãªã®ã§åº§æ¨™ã‚‚ã‚¹ã‚±ãƒ¼ãƒ«åˆã‚ã›
        s = self.flow_downscale
        x1s, y1s, x2s, y2s = x1//s, y1//s, x2//s, y2//s
        Hs, Ws = self._flow.shape[:2]
        x1s = max(0, min(Ws-1, x1s)); x2s = max(0, min(Ws-1, x2s))
        y1s = max(0, min(Hs-1, y1s)); y2s = max(0, min(Hs-1, y2s))
        if x2s <= x1s or y2s <= y1s:
            return 0.0, 0.0

        region = self._flow[y1s:y2s, x1s:x2s, :]
        if region.size == 0:
            return 0.0, 0.0

        mean_flow = region.mean(axis=(0,1))  # [dx, dy] in small image
        dx = float(mean_flow[0] * s)
        dy = float(mean_flow[1] * s)
        return dx, dy

    def _greedy_match(self, dets_xyxy: np.ndarray, classes: np.ndarray) -> List[Tuple[int,int]]:
        """
        ã‚·ãƒ³ãƒ—ãƒ«ãªè²ªæ¬²ãƒãƒƒãƒï¼ˆIoUæœ€å¤§ã‚’é †ã«æ¡ç”¨ï¼‰ã€‚ã‚¯ãƒ©ã‚¹ãŒé•ã†å ´åˆã¯ãƒãƒƒãƒã—ãªã„ã€‚
        æˆ»ã‚Šå€¤: [(track_idx, det_idx), ...]
        """
        if len(self.tracks) == 0 or len(dets_xyxy) == 0:
            return []

        iou_mat = np.zeros((len(self.tracks), len(dets_xyxy)), dtype=float)
        for ti, tr in enumerate(self.tracks):
            for di, det in enumerate(dets_xyxy):
                if tr.cls != int(classes[di]):
                    iou_mat[ti, di] = 0.0
                else:
                    iou_mat[ti, di] = iou_xyxy(tr.bbox_xyxy, det)

        matches = []
        used_tracks = set()
        used_dets = set()
        # IoUãŒé«˜ã„é †ã«ä¸¦ã¹ã¦è²ªæ¬²ã«æ¡ç”¨
        pairs = [(ti, di, iou_mat[ti, di]) for ti in range(len(self.tracks)) for di in range(len(dets_xyxy))]
        pairs.sort(key=lambda x: x[2], reverse=True)
        for ti, di, val in pairs:
            if val < self.iou_threshold:
                break
            if ti in used_tracks or di in used_dets:
                continue
            matches.append((ti, di))
            used_tracks.add(ti)
            used_dets.add(di)
        return matches

    def update(
        self,
        detections: np.ndarray,
        frame_bgr: Optional[np.ndarray] = None
    ) -> List[dict]:
        """
        detections: shape=(N,6)  [x1,y1,x2,y2,score,class_id]
        frame_bgr:  ä»»æ„ã€‚æä¾›ã•ã‚Œã‚‹ã¨å…‰ãƒ•ãƒ­ãƒ¼è£œåŠ©ãŒæœ‰åŠ¹ï¼ˆuse_optical_flow=Trueæ™‚ï¼‰
        æˆ»ã‚Š: å¯è¦–åŒ–ãƒ»ä¿å­˜å‘ã‘ã« dict ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™
              {track_id, bbox, score, class_id, confirmed(bool)}
        """
        # 1) äºˆæ¸¬ï¼ˆå‰å›é€Ÿåº¦ã§å¹³è¡Œç§»å‹•ï¼‰
        for tr in self.tracks:
            tr.predict()

        # 2) ãƒ•ãƒ­ãƒ¼è¨ˆç®—â†’èƒŒæ™¯ã‚·ãƒ•ãƒˆã§è£œæ­£ï¼ˆä»»æ„ï¼‰
        if frame_bgr is not None:
            self._compute_flow(frame_bgr)
            if self.use_optical_flow and self._flow is not None:
                for tr in self.tracks:
                    dx, dy = self._flow_shift(tr.bbox_xyxy)
                    # èƒŒæ™¯ãŒå³ã¸æµã‚Œã¦ã„ã‚Œã°ã€ç‰©ä½“ã¯ç›¸å¯¾çš„ã«å·¦ã¸è¦‹ãˆã‚‹ï¼è£œæ­£ã¯é€†ç¬¦å·
                    tr.bbox_xyxy = tr.bbox_xyxy - np.array([dx, dy, dx, dy], dtype=float)

        # 3) ãƒãƒƒãƒãƒ³ã‚°
        if detections is None or len(detections) == 0:
            matches = []
            dets_xyxy = np.zeros((0,4))
            det_scores = np.zeros((0,))
            det_classes = np.zeros((0,))
        else:
            dets_xyxy = detections[:, :4].astype(float)
            det_scores = detections[:, 4].astype(float)
            det_classes = detections[:, 5].astype(int)
            matches = self._greedy_match(dets_xyxy, det_classes)

        matched_tr = set(t for t,_ in matches)
        matched_dt = set(d for _,d in matches)

        # 4) æ›´æ–°
        for ti, di in matches:
            self.tracks[ti].update(dets_xyxy[di], float(det_scores[di]))
            # ã‚¯ãƒ©ã‚¹ã¯åŸºæœ¬å›ºå®šï¼ˆå¿…è¦ãªã‚‰æ›´æ–°ï¼‰
            # self.tracks[ti].cls = int(det_classes[di])

        # 5) æœªãƒãƒƒãƒæ¤œå‡ºâ†’æ–°è¦ãƒˆãƒ©ãƒƒã‚¯ç”Ÿæˆ
        for di in range(len(dets_xyxy)):
            if di in matched_dt: 
                continue
            cls_i = int(det_classes[di]) if len(det_classes) else 0
            sc_i  = float(det_scores[di]) if len(det_scores) else 0.0
            self.tracks.append(Track(
                track_id=self._next_id,
                bbox_xyxy=dets_xyxy[di].copy(),
                cls=cls_i,
                score=sc_i
            ))
            self._next_id += 1

        # 6) æœªãƒãƒƒãƒãƒˆãƒ©ãƒƒã‚¯ã®å¯¿å‘½ç®¡ç†
        alive_tracks = []
        for tr in self.tracks:
            if tr.time_since_update <= self.max_age:
                alive_tracks.append(tr)
        self.tracks = alive_tracks

        # 7) å‡ºåŠ›
        outputs = []
        for tr in self.tracks:
            confirmed = tr.hits >= self.min_hits or tr.time_since_update == 0
            outputs.append({
                "track_id": tr.track_id,
                "bbox": tr.bbox_xyxy.copy(),
                "score": float(tr.score),
                "class_id": int(tr.cls),
                "confirmed": bool(confirmed),
                "age": tr.age,
                "miss": tr.time_since_update,
            })
        return outputs

ä½¿ã„æ–¹ï¼ˆæœ€å°ä¾‹ï¼‰

import numpy as np
from tracker import SimpleTracker

tracker = SimpleTracker(
    iou_threshold=0.3,  # ãƒãƒƒãƒã®å³ã—ã•
    max_age=15,         # æ¬ æ¸¬è¨±å®¹
    min_hits=3,         # ç¢ºä¿¡åŒ–ã®ã—ãã„
    use_optical_flow=True  # cv2ãŒå…¥ã£ã¦ã„ã‚Œã°ONå¯
)

# ã‚ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ¤œå‡ºï¼ˆä¾‹: [[x1,y1,x2,y2,score,class_id], ...]ï¼‰
detections = np.array([
    [100,120,180,200,0.92, 2],   # class=2 (ä¾‹: car)
    [300,110,340,180,0.88, 0],   # class=0 (ä¾‹: person)
], dtype=float)

# frame_bgr ã¯ä»»æ„ï¼ˆã‚ªãƒ—ãƒ†ã‚£ã‚«ãƒ«ãƒ•ãƒ­ãƒ¼ä½¿ã†ãªã‚‰ç”»åƒBGRã‚’æ¸¡ã™ï¼‰
tracks = tracker.update(detections, frame_bgr=None)
for t in tracks:
    print(t["track_id"], t["bbox"], t["class_id"], t["confirmed"])

ãƒã‚¤ãƒ³ãƒˆ
	â€¢	æ¤œå‡ºå™¨éä¾å­˜ï¼šãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã« [x1,y1,x2,y2,score,class_id] ã‚’æ¸¡ã›ã°å‹•ä½œï¼ˆYOLO/RT-DETR/ä»–ã§ã‚‚OKï¼‰ã€‚
	â€¢	IDç¶­æŒï¼šIoUã§è²ªæ¬²ãƒãƒƒãƒã—ã€å¤–ã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã‚‚ max_age ã®é–“ã¯ä¿æŒã€‚
	â€¢	å®‰å®šåŒ–ï¼šç°¡æ˜“ãªé€Ÿåº¦æ¨å®šã§æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã®ä½ç½®ã‚’äºˆæ¸¬ã€‚
	â€¢	ä»»æ„æ©Ÿèƒ½ï¼šOpenCVãŒã‚ã‚Œã°ã‚ªãƒ—ãƒ†ã‚£ã‚«ãƒ«ãƒ•ãƒ­ãƒ¼è£œåŠ©ã‚’ONã«ã§ãã€èƒŒæ™¯ã®å¤§åŸŸç§»å‹•ã‚’æ¦‚ç®—è£œæ­£ã€‚
	â€¢	æ‹¡å¼µä½™åœ°ï¼šã‚³ã‚¹ãƒˆã«ã€Œä¸­å¿ƒç§»å‹•ã®è¿‘ã•ã€ã‚„ã€Œè¦‹ãŸç›®ç‰¹å¾´(ReID/è‰²ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ )ã€ã‚’åŠ ãˆã‚‹ã¨æ›´ã«å¼·ããªã‚Šã¾ã™ã€‚
	â€¢	ã‚ˆã‚Šé«˜ç²¾åº¦ã«ã—ãŸã‘ã‚Œã°ã€è²ªæ¬²ãƒãƒƒãƒâ†’ãƒãƒ³ã‚¬ãƒªã‚¢ãƒ³æ³•ï¼ˆç·šå½¢å‰²å½“ï¼‰ã«ç½®ãæ›ãˆã€ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã‚’å°å…¥ã—ã¦ãã ã•ã„ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¯ãã®ã¾ã¾ï¼‰ã€‚

å¿…è¦ãªã‚‰ã€ã“ã®SimpleTrackerã‚’ãƒãƒƒãƒ•ã‚¡ä»˜ãã§å‹•ç”»ï¼ˆcv2.VideoCaptureï¼‰ã«æµã—è¾¼ã‚€ã‚µãƒ³ãƒ—ãƒ«ã‚„ã€**æ¤œå‡ºå™¨ã¨ã®æ¥ç¶šä¾‹ï¼ˆYOLO/RT-DETRï¼‰**ã‚‚å‡ºã—ã¾ã™ã€‚





